<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>ARTS 009 :: Lei&#x27;s Notebook</title>
    <meta name="generator" content="Antora 3.0.0">
    <link rel="stylesheet" href="../../../_/css/site-c40d8d4d09.css">
<link rel="apple-touch-icon-precomposed" sizes="57x57" href="../../../apple-touch-icon-57x57.png">
<link rel="apple-touch-icon-precomposed" sizes="114x114" href="../../../apple-touch-icon-114x114.png">
<link rel="apple-touch-icon-precomposed" sizes="72x72" href="../../../apple-touch-icon-72x72.png">
<link rel="apple-touch-icon-precomposed" sizes="144x144" href="../../../apple-touch-icon-144x144.png">
<link rel="apple-touch-icon-precomposed" sizes="60x60" href="../../../apple-touch-icon-60x60.png">
<link rel="apple-touch-icon-precomposed" sizes="120x120" href="../../../apple-touch-icon-120x120.png">
<link rel="apple-touch-icon-precomposed" sizes="76x76" href="../../../apple-touch-icon-76x76.png">
<link rel="apple-touch-icon-precomposed" sizes="152x152" href="../../../apple-touch-icon-152x152.png">
<link rel="icon" type="image/png" href="../../../favicon-196x196.png" sizes="196x196">
<link rel="icon" type="image/png" href="../../../favicon-96x96.png" sizes="96x96">
<link rel="icon" type="image/png" href="../../../favicon-32x32.png" sizes="32x32">
<link rel="icon" type="image/png" href="../../../favicon-16x16.png" sizes="16x16">
<link rel="icon" type="image/png" href="../../../favicon-128.png" sizes="128x128">
  </head>
  <body class="article">
<header class="header">
  <nav class="navbar">
    <div class="navbar-brand">
      <a class="nav-logo" href="../../.."></a>
      <div id="topbar-nav" class="navbar-menu">
        <div class="navbar-end">
                <a class="navbar-item-section navbar-item navbar-topics" href="../../../arts/">
                  <img alt="ARTS" src="/_/img/blog-e21e601f33.svg">
                  ARTS
                </a>
        </div>
      </div>
      <div class="navbar-fill"></div>
      <div class="break-row"></div>
      <button class="navbar-burger" data-target="topbar-nav" type="button" aria-label="Menu">
        <span></span>
        <span></span>
        <span></span>
      </button>
    </div>
  </nav>
</header>
<a id="top"></a>
<div class="body">
<div class="nav-container" data-component="arts" data-version="latest">
  <aside class="nav">
    <div class="panels">
<div class="nav-panel-menu is-active">
  <nav class="nav-menu" data-panel="menu">
    <h3 class="title"><a href="../index.html">ARTS</a></h3>
<ul class="nav-list">
  <li class="nav-item" data-depth="0">
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle" aria-label="Expand or contract topic"></button>
    <span class="nav-text">ARTS</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle" aria-label="Expand or contract topic"></button>
    <span class="nav-text">2021</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="2021-05-07-ARTS-001.html">ARTS 001</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="2021-11-08-ARTS-002.html">ARTS 002</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="2021-11-15-ARTS-003.html">ARTS 003</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="2021-11-25-ARTS-004.html">ARTS 004</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="2021-12-02-ARTS-005.html">ARTS 005</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle" aria-label="Expand or contract topic"></button>
    <span class="nav-text">2022</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="2022-03-03-ARTS-006.html">ARTS 006</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="2022-03-07-ARTS-007.html">ARTS 007</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="2022-03-14-ARTS-008.html">ARTS 008</a>
  </li>
  <li class="nav-item is-current-page" data-depth="3">
    <a class="nav-link" href="2022-03-21-ARTS-009.html">ARTS 009</a>
  </li>
</ul>
  </li>
</ul>
  </li>
</ul>
  </li>
</ul>
  </nav>
</div>
<div class="nav-panel-explore" data-panel="explore">
  <div class="context">
    <span class="title">ARTS</span>
<span class="version">latest</span>  </div>
  <ul class="components">
    <li class="component is-current"><span class="title">ARTS</span>
      <ul class="versions">
        <li class="version is-current">
          <a href="../index.html">latest</a>
        </li>
      </ul></li>
  </ul>
</div>
    </div>
  </aside>
</div>
<main class="article">
<nav class="toolbar">
<button class="nav-toggle" aria-label="Toggle submenu"></button>
  <a href="../index.html" class="home-link"></a>
<nav class="breadcrumbs" aria-label="breadcrumbs">
  <ul>
    <li>ARTS</li>
    <li>2022</li>
    <li><a href="2022-03-21-ARTS-009.html">ARTS 009</a></li>
  </ul>
</nav>
</nav>
  <div class="content">
<article class="doc">
<h1 class="page">ARTS 009</h1>
<div class="sect1">
<h2 id="_algorithm"><a class="anchor" href="#_algorithm"></a>Algorithm</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_101_symmetric_tree"><a class="anchor" href="#_101_symmetric_tree"></a>101. Symmetric Tree</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">package leetcode.problems.p01;

import leetcode.bean.TreeNode;
import org.junit.jupiter.api.Test;

import java.util.Deque;
import java.util.LinkedList;

import static leetcode.bean.TreeNode.newTreeNode;
import static org.junit.jupiter.api.Assertions.assertFalse;
import static org.junit.jupiter.api.Assertions.assertTrue;

/**
 * 101. Symmetric Tree
 *
 * @link https://leetcode.com/problems/symmetric-tree/
 * @author zhanglei
 * @date 2022/3/14
 */
class P0101 {

    // interactive solution
    public boolean isSymmetric(TreeNode root) {
        Deque&lt;TreeNode&gt; l = new LinkedList&lt;&gt;();
        Deque&lt;TreeNode&gt; r = new LinkedList&lt;&gt;();
        l.push(root.left);
        r.push(root.right);
        while (!l.isEmpty() &amp;&amp; !r.isEmpty()) {
            TreeNode left = l.pop();
            TreeNode right = r.pop();
            if (left == null &amp;&amp; right == null) {
                continue;
            } else if (left != null &amp;&amp; right != null &amp;&amp; left.val == right.val) {
                l.push(left.left);
                l.push(left.right);
                r.push(right.right);
                r.push(right.left);
            } else {
                return false;
            }
        }
        return l.isEmpty() &amp;&amp; r.isEmpty();
    }

    /*
    // recursive solution
    public boolean isSymmetric(TreeNode root) {
        return isSymmetric(root.left, root.right);
    }

    static boolean isSymmetric(TreeNode l, TreeNode r) {
        if (l != null &amp;&amp; r != null) {
            return l.val == r.val &amp;&amp; isSymmetric(l.left, r.right) &amp;&amp; isSymmetric(l.right, r.left);
        } else {
            return l == null &amp;&amp; r == null;
        }
    }
    */

    @Test
    void test1() {
        assertTrue(isSymmetric(newTreeNode(1, 2, 2, 3, 4, 4, 3)));
    }

    @Test
    void test2() {
        assertFalse(isSymmetric(newTreeNode(1, 2, 2, null, 3, null, 3)));
    }

    @Test
    void test166() {
        assertFalse(isSymmetric(newTreeNode(1, 2, 3)));
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_559_maximum_depth_of_n_ary_tree"><a class="anchor" href="#_559_maximum_depth_of_n_ary_tree"></a>559. Maximum Depth of N-ary Tree</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">package leetcode.problems.p05;

import leetcode.bean.Node;
import org.junit.jupiter.api.Test;

import static leetcode.bean.Node.newNode;
import static org.junit.jupiter.api.Assertions.assertEquals;

/**
 * 559. Maximum Depth of N-ary Tree
 *
 * @link https://leetcode.com/problems/maximum-depth-of-n-ary-tree/
 * @author zhanglei
 * @date 2022/3/14
 */
class P0559 {
    // recursive solution
    public int maxDepth(Node root) {
        if (root == null) {
            return 0;
        } else if (root.children == null) {
            return 1;
        } else {
            return 1 + root.children.stream().mapToInt(this::maxDepth).max().orElse(0);
        }
    }

    /*
    // interactive solution
    public int maxDepth(Node root) {
        if (root == null) {
            return 0;
        }
        Deque&lt;Node&gt; deque = new LinkedList&lt;&gt;();
        deque.offer(root);
        int depth = 0;
        while (!deque.isEmpty()) {
            for (int i = 0, j = deque.size(); i &lt; j; i++) {
                Node node = deque.poll();
                if (node.children != null) {
                    for (Node child : node.children) {
                        deque.offer(child);
                    }
                }
            }
            depth++;
        }
        return depth;
    }
    */

    @Test
    void test1() {
        assertEquals(3, maxDepth(newNode(1, null, 3, 2, 4, null, 5, 6)));
    }

    @Test
    void test2() {
        assertEquals(
                5,
                maxDepth(
                        newNode(
                                1, null, 2, 3, 4, 5, null, null, 6, 7, null, 8, null, 9, 10, null,
                                null, 11, null, 12, null, 13, null, null, 14)));
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_222_count_complete_tree_nodes"><a class="anchor" href="#_222_count_complete_tree_nodes"></a>222. Count Complete Tree Nodes</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">package leetcode.problems.p02;

import leetcode.bean.TreeNode;
import org.junit.jupiter.api.Test;

import static leetcode.bean.TreeNode.newTreeNode;
import static org.junit.jupiter.api.Assertions.assertEquals;

/**
 * 222. Count Complete Tree Nodes
 *
 * @link https://leetcode.com/problems/count-complete-tree-nodes/
 * @author zhanglei
 * @date 2022/3/14
 */
class P0222 {
    // time complexity: O(log(n)^2)
    // space complexity: O(log(n))
    public int countNodes(TreeNode root) {
        int height = height(root);
        if (height &lt; 0) {
            return 0;
        }

        int rh = height(root.right);
        if (rh == height - 1) {
            // left is full, height(left) = h - 1
            return (1 &lt;&lt; height) + countNodes(root.right);
        } else {
            // right is full, height(right) = h - 2
            return (1 &lt;&lt; height - 1) + countNodes(root.left);
        }
    }

    static int height(TreeNode root) {
        int height = -1;
        TreeNode node = root;
        while (node != null) {
            height++;
            node = node.left;
        }
        return height;
    }

    /*
    // time complexity: O(n)
    // space complexity: O(n)
    public int countNodes(TreeNode root) {
        if (root == null) {
            return 0;
        }
        Deque&lt;TreeNode&gt; deque = new LinkedList&lt;&gt;();
        deque.offer(root);
        int size = 0;
        while (!deque.isEmpty()) {
            TreeNode node = deque.poll();
            size++;
            if (node.left != null) {
                deque.offer(node.left);
            }
            if (node.right != null) {
                deque.offer(node.right);
            }
        }
        return size;
    }
    */

    @Test
    void test1() {
        assertEquals(6, countNodes(newTreeNode(1, 2, 3, 4, 5, 6)));
    }

    @Test
    void test2() {
        assertEquals(0, countNodes(newTreeNode()));
    }

    @Test
    void test3() {
        assertEquals(1, countNodes(newTreeNode(1)));
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_110_balanced_binary_tree"><a class="anchor" href="#_110_balanced_binary_tree"></a>110. Balanced Binary Tree</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">package leetcode.problems.p01;

import leetcode.bean.TreeNode;
import org.junit.jupiter.api.Test;

import static leetcode.bean.TreeNode.newTreeNode;
import static org.junit.jupiter.api.Assertions.assertFalse;
import static org.junit.jupiter.api.Assertions.assertTrue;

/**
 * 110. Balanced Binary Tree
 *
 * @link https://leetcode.com/problems/balanced-binary-tree/
 * @author zhanglei
 * @date 2022/3/15
 */
class P0110 {
    public boolean isBalanced(TreeNode root) {
        return height(root) != Integer.MIN_VALUE;
    }

    static int height(TreeNode root) {
        if (root == null) {
            return -1;
        }
        int leftHeight = height(root.left);
        if (leftHeight == Integer.MIN_VALUE) {
            return Integer.MIN_VALUE;
        }
        int rightHeight = height(root.right);
        if (rightHeight == Integer.MIN_VALUE) {
            return Integer.MIN_VALUE;
        }
        if (Math.abs(leftHeight - rightHeight) &gt; 1) {
            return Integer.MIN_VALUE;
        }
        return Math.max(leftHeight, rightHeight) + 1;
    }

    @Test
    void test1() {
        assertTrue(isBalanced(newTreeNode(3, 9, 20, null, null, 15, 7)));
    }

    @Test
    void test2() {
        assertFalse(isBalanced(newTreeNode(1, 2, 2, 3, 3, null, null, 4, 4)));
    }

    @Test
    void test3() {
        assertTrue(isBalanced(newTreeNode()));
    }

    @Test
    void test219() {
        assertTrue(isBalanced(newTreeNode(1, 2, 3, 4, 5, 6, null, 8)));
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_257_binary_tree_paths"><a class="anchor" href="#_257_binary_tree_paths"></a>257. Binary Tree Paths</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">package leetcode.problems.p02;

import leetcode.bean.TreeNode;
import org.junit.jupiter.api.Test;

import java.util.ArrayList;
import java.util.Deque;
import java.util.LinkedList;
import java.util.List;

import static leetcode.bean.TreeNode.newTreeNode;
import static org.junit.jupiter.api.Assertions.assertEquals;

/**
 * 257. Binary Tree Paths
 *
 * @link https://leetcode.com/problems/binary-tree-paths/
 * @author zhanglei
 * @date 2022/3/15
 */
class P0257 {
    // iterative solution
    public List&lt;String&gt; binaryTreePaths(TreeNode root) {
        List&lt;String&gt; result = new ArrayList&lt;&gt;();
        if (root == null) {
            return result;
        }
        Deque&lt;String&gt; paths = new LinkedList&lt;&gt;();
        Deque&lt;TreeNode&gt; deque = new LinkedList&lt;&gt;();
        deque.offerLast(root);
        paths.offerLast("");
        while (!deque.isEmpty()) {
            String path = paths.pollLast();
            TreeNode node = deque.pollLast();
            path += node.val;
            if (node.left == null &amp;&amp; node.right == null) {
                result.add(path);
            }
            if (node.right != null) {
                deque.offerLast(node.right);
                paths.offerLast(path + "-&gt;");
            }
            if (node.left != null) {
                deque.offerLast(node.left);
                paths.offerLast(path + "-&gt;");
            }
        }
        return result;
    }

    /*
    // recursive solution
    public List&lt;String&gt; binaryTreePaths(TreeNode root) {
        List&lt;String&gt; result = new ArrayList&lt;&gt;();
        if (root != null) {
            preorderTraversal(root, new LinkedList&lt;&gt;(), result);
        }
        return result;
    }

    static void preorderTraversal(TreeNode root, Deque&lt;String&gt; path, List&lt;String&gt; result) {
        path.offerLast(String.valueOf(root.val));
        if (root.left == null &amp;&amp; root.right == null) {
            result.add(String.join("-&gt;", path));
        }
        if (root.left != null) {
            preorderTraversal(root.left, path, result);
            path.pollLast();
        }
        if (root.right != null) {
            preorderTraversal(root.right, path, result);
            path.pollLast();
        }
    }
    */

    @Test
    void test1() {
        assertEquals("[1-&gt;2-&gt;5, 1-&gt;3]", binaryTreePaths(newTreeNode(1, 2, 3, null, 5)).toString());
    }

    @Test
    void test2() {
        assertEquals("[1]", binaryTreePaths(newTreeNode(1)).toString());
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_404_sum_of_left_leaves"><a class="anchor" href="#_404_sum_of_left_leaves"></a>404. Sum of Left Leaves</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">package leetcode.problems.p04;

import leetcode.bean.TreeNode;
import org.junit.jupiter.api.Test;

import static leetcode.bean.TreeNode.newTreeNode;
import static org.junit.jupiter.api.Assertions.assertEquals;

/**
 * 404. Sum of Left Leaves
 *
 * @link https://leetcode.com/problems/sum-of-left-leaves/
 * @author zhanglei
 * @date 2022/3/15
 */
class P0404 {
    public int sumOfLeftLeaves(TreeNode root) {
        if (root == null) {
            return 0;
        }
        int result = 0;
        if (root.left != null) {
            if (root.left.left == null &amp;&amp; root.left.right == null) {
                result += root.left.val;
            } else {
                result += sumOfLeftLeaves(root.left);
            }
        }
        result += sumOfLeftLeaves(root.right);
        return result;
    }

    @Test
    void test1() {
        assertEquals(24, sumOfLeftLeaves(newTreeNode(3, 9, 20, null, null, 15, 7)));
    }

    @Test
    void test2() {
        assertEquals(0, sumOfLeftLeaves(newTreeNode(1)));
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_513_find_bottom_left_tree_value"><a class="anchor" href="#_513_find_bottom_left_tree_value"></a>513. Find Bottom Left Tree Value</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">package leetcode.problems.p05;

import leetcode.bean.TreeNode;
import org.junit.jupiter.api.Test;

import static leetcode.bean.TreeNode.newTreeNode;
import static org.junit.jupiter.api.Assertions.assertEquals;

/**
 * 513. Find Bottom Left Tree Value
 *
 * @link https://leetcode.com/problems/find-bottom-left-tree-value/
 * @author zhanglei
 * @date 2022/3/15
 */
class P0513 {

    // recursive solution
    public int findBottomLeftValue(TreeNode root) {
        if (root == null) {
            return -1;
        }
        int[] result = new int[] {-1, -1};
        findBottomLeftValue(root, 0, result);
        return result[1];
    }

    static void findBottomLeftValue(TreeNode root, int depth, int[] result) {
        if (result[0] &lt; depth) {
            result[0] = depth;
            result[1] = root.val;
        }
        if (root.left != null) {
            findBottomLeftValue(root.left, depth + 1, result);
        }
        if (root.right != null) {
            findBottomLeftValue(root.right, depth + 1, result);
        }
    }

    /*
    // interactive solution
    public int findBottomLeftValue(TreeNode root) {
        int result = -1;
        if (root == null) {
            return result;
        }
        Deque&lt;TreeNode&gt; deque = new LinkedList&lt;&gt;();
        deque.offer(root);
        while (!deque.isEmpty()) {
            result = deque.peek().val;
            for (int i = 0, j = deque.size(); i &lt; j; i++) {
                TreeNode node = deque.poll();
                if (node.left != null) {
                    deque.offer(node.left);
                }
                if (node.right != null) {
                    deque.offer(node.right);
                }
            }
        }
        return result;
    }
    */

    @Test
    void test1() {
        assertEquals(1, findBottomLeftValue(newTreeNode(2, 1, 3)));
    }

    @Test
    void test2() {
        assertEquals(7, findBottomLeftValue(newTreeNode(1, 2, 3, 4, null, 5, 6, null, null, 7)));
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_112_path_sum"><a class="anchor" href="#_112_path_sum"></a>112. Path Sum</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">package leetcode.problems.p01;

import leetcode.bean.TreeNode;
import org.junit.jupiter.api.Test;

import java.util.Deque;
import java.util.LinkedList;

import static leetcode.bean.TreeNode.newTreeNode;
import static org.junit.jupiter.api.Assertions.assertFalse;
import static org.junit.jupiter.api.Assertions.assertTrue;

/**
 * 112. Path Sum
 *
 * @link https://leetcode.com/problems/path-sum/
 * @author zhanglei
 * @date 2022/3/16
 */
class P0112 {

    // interactive solution
    public boolean hasPathSum(TreeNode root, int targetSum) {
        if (root == null) {
            return false;
        }
        Deque&lt;TreeNode&gt; deque = new LinkedList&lt;&gt;();
        deque.offer(root);
        Deque&lt;Integer&gt; result = new LinkedList&lt;&gt;();
        result.offer(0);
        while (!deque.isEmpty()) {
            for (int i = 0, j = deque.size(); i &lt; j; i++) {
                TreeNode node = deque.poll();
                Integer sum = result.poll() + node.val;
                if (targetSum == sum &amp;&amp; node.left == null &amp;&amp; node.right == null) {
                    return true;
                }
                if (node.left != null) {
                    deque.offer(node.left);
                    result.offer(sum);
                }
                if (node.right != null) {
                    deque.offer(node.right);
                    result.offer(sum);
                }
            }
        }
        return false;
    }

    /*
    // recursive solution
    public boolean hasPathSum(TreeNode root, int targetSum) {
        return root != null
                &amp;&amp; (root.val == targetSum &amp;&amp; root.left == null &amp;&amp; root.right == null
                        || hasPathSum(root.left, targetSum - root.val)
                        || hasPathSum(root.right, targetSum - root.val));
    }
    */

    @Test
    void test1() {
        assertTrue(
                hasPathSum(newTreeNode(5, 4, 8, 11, null, 13, 4, 7, 2, null, null, null, 1), 22));
    }

    @Test
    void test2() {
        assertFalse(hasPathSum(newTreeNode(1, 2, 3), 5));
    }

    @Test
    void test3() {
        assertFalse(hasPathSum(newTreeNode(), 0));
    }

    @Test
    void test71() {
        assertFalse(hasPathSum(newTreeNode(1, 2), 1));
    }

    @Test
    void test83() {
        assertTrue(hasPathSum(newTreeNode(-2, null, -3), -5));
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_106_construct_binary_tree_from_inorder_and_postorder_traversal"><a class="anchor" href="#_106_construct_binary_tree_from_inorder_and_postorder_traversal"></a>106. Construct Binary Tree from Inorder and Postorder Traversal</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">package leetcode.problems.p01;

import leetcode.bean.TreeNode;
import org.junit.jupiter.api.Test;

import static leetcode.bean.TreeNode.print;
import static org.junit.jupiter.api.Assertions.assertEquals;

/**
 * 106. Construct Binary Tree from Inorder and Postorder Traversal
 *
 * @link https://leetcode.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/
 * @refrence https://www.geeksforgeeks.org/construct-a-binary-tree-from-postorder-and-inorder/
 * @author zhanglei
 * @date 2022/3/16
 */
class P0106 {
    public TreeNode buildTree(int[] inorder, int[] postorder) {
        return buildTree(inorder, 0, inorder.length - 1, postorder, 0, postorder.length - 1);
    }

    static TreeNode buildTree(int[] inorder, int is, int ie, int[] postorder, int ps, int pe) {
        int rootVal = postorder[pe];
        int rootIndex = find(inorder, is, ie, rootVal);
        TreeNode root = new TreeNode(rootVal);
        if (rootIndex != is) {
            root.left =
                    buildTree(inorder, is, rootIndex - 1, postorder, ps, ps + rootIndex - 1 - is);
        }
        if (rootIndex != ie) {
            root.right =
                    buildTree(inorder, rootIndex + 1, ie, postorder, rootIndex + pe - ie, pe - 1);
        }
        return root;
    }

    static int find(int[] inorder, int i, int j, int val) {
        for (int k = i; k &lt;= j; k++) {
            if (inorder[k] == val) {
                return k;
            }
        }
        return -1;
    }

    @Test
    void test1() {
        int[] inorder = {9, 3, 15, 20, 7}, postorder = {9, 15, 7, 20, 3};
        assertEquals("[3,9,20,null,null,15,7]", print(buildTree(inorder, postorder)));
    }

    @Test
    void test2() {
        int[] inorder = {-1}, postorder = {-1};
        assertEquals("[-1]", print(buildTree(inorder, postorder)));
    }

    @Test
    void test3() {
        int[] inorder = {2, 1}, postorder = {2, 1};
        assertEquals("[1,2]", print(buildTree(inorder, postorder)));
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_105_construct_binary_tree_from_preorder_and_inorder_traversal"><a class="anchor" href="#_105_construct_binary_tree_from_preorder_and_inorder_traversal"></a>105. Construct Binary Tree from Preorder and Inorder Traversal</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">package leetcode.problems.p01;

import leetcode.bean.TreeNode;
import org.junit.jupiter.api.Test;

import static leetcode.bean.TreeNode.print;
import static org.junit.jupiter.api.Assertions.assertEquals;

/**
 * 105. Construct Binary Tree from Preorder and Inorder Traversal
 *
 * @link https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/
 * @author zhanglei
 * @date 2022/3/16
 */
class P0105 {
    public TreeNode buildTree(int[] preorder, int[] inorder) {
        return buildTree(preorder, 0, preorder.length - 1, inorder, 0, inorder.length - 1);
    }

    static TreeNode buildTree(int[] preorder, int ps, int pe, int[] inorder, int is, int ie) {
        if (ps &gt; pe) {
            return null;
        }
        int rootVal = preorder[ps];
        int rootIndex = find(inorder, is, ie, rootVal);
        TreeNode root = new TreeNode(rootVal);
        // (ps + 1, r - is + ps) (pe - ie + r + 1, pe)
        // (is,     r - 1)       (r + 1,           ie)
        root.left = buildTree(preorder, ps + 1, rootIndex - is + ps, inorder, is, rootIndex - 1);
        root.right = buildTree(preorder, pe - ie + rootIndex + 1, pe, inorder, rootIndex + 1, ie);
        return root;
    }

    static int find(int[] inorder, int is, int ie, int rootVal) {
        for (int i = is; i &lt;= ie; i++) {
            if (inorder[i] == rootVal) {
                return i;
            }
        }
        return -1;
    }

    @Test
    void test1() {
        int[] preorder = {3, 9, 20, 15, 7}, inorder = {9, 3, 15, 20, 7};
        assertEquals("[3,9,20,null,null,15,7]", print(buildTree(preorder, inorder)));
    }

    @Test
    void test2() {
        int[] preorder = {-1}, inorder = {-1};
        assertEquals("[-1]", print(buildTree(preorder, inorder)));
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_654_maximum_binary_tree"><a class="anchor" href="#_654_maximum_binary_tree"></a>654. Maximum Binary Tree</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">package leetcode.problems.p06;

import leetcode.bean.TreeNode;
import org.junit.jupiter.api.Test;

import java.util.ArrayDeque;
import java.util.Deque;

import static leetcode.bean.TreeNode.print;
import static org.junit.jupiter.api.Assertions.assertEquals;

/**
 * 654. Maximum Binary Tree
 *
 * @link https://leetcode.com/problems/maximum-binary-tree/
 * @reference
 *     https://leetcode.com/problems/maximum-binary-tree/discuss/106156/Java-worst-case-O(N)-solution
 * @author zhanglei
 * @date 2022/3/17
 */
class P0654 {

    // O(n)
    // TODO clean code
    public TreeNode constructMaximumBinaryTree(int[] nums) {
        if (nums == null || nums.length == 0) {
            return null;
        }
        Deque&lt;TreeNode&gt; deque = new ArrayDeque&lt;&gt;(nums.length);
        deque.offerLast(new TreeNode(nums[0]));
        for (int i = 1; i &lt; nums.length; i++) {
            if (deque.peekLast().val &gt; nums[i]) {
                deque.peekLast().right = new TreeNode(nums[i]);
                deque.offerLast(deque.peekLast().right);
            } else {
                TreeNode node = deque.pollLast();
                while (!deque.isEmpty() &amp;&amp; deque.peekLast().val &lt; nums[i]) {
                    node = deque.pollLast();
                }
                TreeNode temp = new TreeNode(nums[i]);
                temp.left = node;
                if (!deque.isEmpty()) {
                    deque.peekLast().right = temp;
                    deque.offerLast(deque.peekLast().right);
                } else {
                    deque.offerLast(temp);
                }
            }
        }
        return deque.peekFirst();
    }

    /*
    public TreeNode constructMaximumBinaryTree(int[] nums) {
        return constructMaximumBinaryTree(nums, 0, nums.length - 1);
    }

    static TreeNode constructMaximumBinaryTree(int[] nums, int s, int e) {
        if (s &gt; e) {
            return null;
        }
        int max = find(nums, s, e);
        TreeNode root = new TreeNode(nums[max]);
        root.left = constructMaximumBinaryTree(nums, s, max - 1);
        root.right = constructMaximumBinaryTree(nums, max + 1, e);
        return root;
    }

    static int find(int[] nums, int s, int e) {
        int max = s;
        for (int i = s + 1; i &lt;= e; i++) {
            if (nums[i] &gt; nums[max]) {
                max = i;
            }
        }
        return max;
    }
    */

    @Test
    void test1() {
        int[] nums = {3, 2, 1, 6, 0, 5};
        assertEquals("[6,3,5,null,2,0,null,null,1]", print(constructMaximumBinaryTree(nums)));
    }

    @Test
    void test2() {
        int[] nums = {3, 2, 1};
        assertEquals("[3,null,2,null,1]", print(constructMaximumBinaryTree(nums)));
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_review"><a class="anchor" href="#_review"></a>Review</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_ballerina_for_full_stack_developers_a_guide_to_creating_backend_apis"><a class="anchor" href="#_ballerina_for_full_stack_developers_a_guide_to_creating_backend_apis"></a><a href="https://www.infoq.com/articles/ballerina-fullstack-rest-api/">Ballerina for Full-Stack Developers: A Guide to Creating Backend APIs</a></h3>
<div class="paragraph">
<p>a common Web Backend Service should have:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>REST APIs</p>
<div class="olist loweralpha">
<ol class="loweralpha" type="a">
<li>
<p>OpenAPI Specification</p>
</li>
<li>
<p>Explicit Error Handling</p>
</li>
<li>
<p>WebSockets</p>
</li>
</ol>
</div>
</li>
<li>
<p>Services</p>
<div class="olist loweralpha">
<ol class="loweralpha" type="a">
<li>
<p>CRUD Service</p>
</li>
<li>
<p>Securing Service</p>
</li>
</ol>
</div>
</li>
<li>
<p>Authentication</p>
<div class="ulist">
<ul>
<li>
<p>JWT</p>
</li>
<li>
<p>OAuth2</p>
</li>
<li>
<p>Basic Auth</p>
</li>
</ul>
</div>
</li>
<li>
<p>Authorization</p>
</li>
<li>
<p>Observability</p>
<div class="olist loweralpha">
<ol class="loweralpha" type="a">
<li>
<p>Tracing</p>
</li>
<li>
<p>Logging</p>
</li>
<li>
<p>Metrics</p>
</li>
</ol>
</div>
</li>
<li>
<p>Persistence Layer</p>
</li>
<li>
<p>Resiliency</p>
<div class="olist loweralpha">
<ol class="loweralpha" type="a">
<li>
<p>Circuit Breaker</p>
</li>
<li>
<p>Load Balancer</p>
</li>
<li>
<p>Failover</p>
</li>
<li>
<p>Retry</p>
</li>
</ol>
</div>
</li>
<li>
<p>Caching</p>
</li>
<li>
<p>Testing</p>
</li>
<li>
<p>CI/CD</p>
</li>
</ol>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_tip"><a class="anchor" href="#_tip"></a>Tip</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_bash_parameter_indirect_expansion"><a class="anchor" href="#_bash_parameter_indirect_expansion"></a>Bash Parameter Indirect Expansion</h3>
<div class="paragraph">
<p>If the first character of parameter is an exclamation point (!), and parameter is not a nameref, it introduces a level of indirection. Bash uses the value formed by expanding the rest of parameter as the new parameter; this is then expanded and that value is used in the rest of the expansion, rather than the expansion of the original parameter. This is known as indirect expansion.</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ red="the color red"
$ green="the color green"

$ color=red
$ echo "${!color}"
the color red
$ color=green
$ echo "${!color}"
the color green</pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_observe_the_status_of_github"><a class="anchor" href="#_observe_the_status_of_github"></a>Observe The status of GitHub</h3>
<div class="paragraph">
<p><a href="https://www.githubstatus.com/" class="bare">https://www.githubstatus.com/</a></p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_share"><a class="anchor" href="#_share"></a>Share</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_为什么_java_容器推荐使用_exitonoutofmemoryerror_而非_heapdumponoutofmemoryerror"><a class="anchor" href="#_为什么_java_容器推荐使用_exitonoutofmemoryerror_而非_heapdumponoutofmemoryerror"></a><a href="https://xie.infoq.cn/article/ec91147d9da7bbaeaa4fca119">为什么 Java 容器推荐使用 ExitOnOutOfMemoryError 而非 HeapDumpOnOutOfMemoryError?</a></h3>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>新的技术带来新的变革, 我们需要以发展的眼光看待"最佳实践, 最佳配置".
2016 年, 针对虚机部署的 Java 的最优参数, 在今天来看, 并不一定仍是最优解.</p>
</div>
</blockquote>
</div>
</div>
</div>
</div>
</article>
<aside class="toc sidebar" data-title="Contents" data-levels="2">
  <div class="toc-menu"></div>
</aside>
  </div>
</main>
</div>
    <div class="footer-tools">
        <a href="#top" title="Reach the top of the page">Back to top</a>
    </div>
<script src="../../../_/js/vendor/algoliasearch-77ad57d83c.js"></script>
<script src="../../../_/js/site-ca1c0b0367.js"></script>
<script async src="../../../_/js/vendor/highlight-0a351063af.js"></script>
<script async src="../../../_/js/vendor/svg4everybody-195d47ce7d.js"></script>
              </body>
</html>
