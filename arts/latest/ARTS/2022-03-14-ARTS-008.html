<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>ARTS 008 :: Lei&#x27;s Notebook</title>
    <meta name="generator" content="Antora 3.0.0">
    <link rel="stylesheet" href="../../../_/css/site-c40d8d4d09.css">
<link rel="apple-touch-icon-precomposed" sizes="57x57" href="../../../apple-touch-icon-57x57.png">
<link rel="apple-touch-icon-precomposed" sizes="114x114" href="../../../apple-touch-icon-114x114.png">
<link rel="apple-touch-icon-precomposed" sizes="72x72" href="../../../apple-touch-icon-72x72.png">
<link rel="apple-touch-icon-precomposed" sizes="144x144" href="../../../apple-touch-icon-144x144.png">
<link rel="apple-touch-icon-precomposed" sizes="60x60" href="../../../apple-touch-icon-60x60.png">
<link rel="apple-touch-icon-precomposed" sizes="120x120" href="../../../apple-touch-icon-120x120.png">
<link rel="apple-touch-icon-precomposed" sizes="76x76" href="../../../apple-touch-icon-76x76.png">
<link rel="apple-touch-icon-precomposed" sizes="152x152" href="../../../apple-touch-icon-152x152.png">
<link rel="icon" type="image/png" href="../../../favicon-196x196.png" sizes="196x196">
<link rel="icon" type="image/png" href="../../../favicon-96x96.png" sizes="96x96">
<link rel="icon" type="image/png" href="../../../favicon-32x32.png" sizes="32x32">
<link rel="icon" type="image/png" href="../../../favicon-16x16.png" sizes="16x16">
<link rel="icon" type="image/png" href="../../../favicon-128.png" sizes="128x128">
  </head>
  <body class="article">
<header class="header">
  <nav class="navbar">
    <div class="navbar-brand">
      <a class="nav-logo" href="../../.."></a>
      <div id="topbar-nav" class="navbar-menu">
        <div class="navbar-end">
                <a class="navbar-item-section navbar-item navbar-topics" href="../../../arts/">
                  <img alt="ARTS" src="/_/img/blog-e21e601f33.svg">
                  ARTS
                </a>
        </div>
      </div>
      <div class="navbar-fill"></div>
      <div class="break-row"></div>
      <button class="navbar-burger" data-target="topbar-nav" type="button" aria-label="Menu">
        <span></span>
        <span></span>
        <span></span>
      </button>
    </div>
  </nav>
</header>
<a id="top"></a>
<div class="body">
<div class="nav-container" data-component="arts" data-version="latest">
  <aside class="nav">
    <div class="panels">
<div class="nav-panel-menu is-active">
  <nav class="nav-menu" data-panel="menu">
    <h3 class="title"><a href="../index.html">ARTS</a></h3>
<ul class="nav-list">
  <li class="nav-item" data-depth="0">
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle" aria-label="Expand or contract topic"></button>
    <span class="nav-text">ARTS</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle" aria-label="Expand or contract topic"></button>
    <span class="nav-text">2021</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="2021-05-07-ARTS-001.html">ARTS 001</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="2021-11-08-ARTS-002.html">ARTS 002</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="2021-11-15-ARTS-003.html">ARTS 003</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="2021-11-25-ARTS-004.html">ARTS 004</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="2021-12-02-ARTS-005.html">ARTS 005</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle" aria-label="Expand or contract topic"></button>
    <span class="nav-text">2022</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="2022-03-03-ARTS-006.html">ARTS 006</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="2022-03-07-ARTS-007.html">ARTS 007</a>
  </li>
  <li class="nav-item is-current-page" data-depth="3">
    <a class="nav-link" href="2022-03-14-ARTS-008.html">ARTS 008</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="2022-03-21-ARTS-009.html">ARTS 009</a>
  </li>
</ul>
  </li>
</ul>
  </li>
</ul>
  </li>
</ul>
  </nav>
</div>
<div class="nav-panel-explore" data-panel="explore">
  <div class="context">
    <span class="title">ARTS</span>
<span class="version">latest</span>  </div>
  <ul class="components">
    <li class="component is-current"><span class="title">ARTS</span>
      <ul class="versions">
        <li class="version is-current">
          <a href="../index.html">latest</a>
        </li>
      </ul></li>
  </ul>
</div>
    </div>
  </aside>
</div>
<main class="article">
<nav class="toolbar">
<button class="nav-toggle" aria-label="Toggle submenu"></button>
  <a href="../index.html" class="home-link"></a>
<nav class="breadcrumbs" aria-label="breadcrumbs">
  <ul>
    <li>ARTS</li>
    <li>2022</li>
    <li><a href="2022-03-14-ARTS-008.html">ARTS 008</a></li>
  </ul>
</nav>
</nav>
  <div class="content">
<article class="doc">
<h1 class="page">ARTS 008</h1>
<div class="sect1">
<h2 id="_algorithm"><a class="anchor" href="#_algorithm"></a>Algorithm</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_144_binary_tree_preorder_traversal"><a class="anchor" href="#_144_binary_tree_preorder_traversal"></a>144. Binary Tree Preorder Traversal</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">package leetcode.problems.p01;

import leetcode.bean.TreeNode;
import org.junit.jupiter.api.Test;

import java.util.ArrayList;
import java.util.Deque;
import java.util.LinkedList;
import java.util.List;

import static leetcode.bean.TreeNode.newTreeNode;
import static org.junit.jupiter.api.Assertions.assertEquals;

/**
 * 144. Binary Tree Preorder Traversal
 *
 * @link https://leetcode.com/problems/binary-tree-preorder-traversal/
 * @author zhanglei
 * @date 2022/3/10
 */
class P0144 {

    // interactive solution
    public List&lt;Integer&gt; preorderTraversal(TreeNode root) {
        List&lt;Integer&gt; result = new ArrayList&lt;&gt;();
        if (root == null) {
            return result;
        }
        Deque&lt;TreeNode&gt; deque = new LinkedList&lt;&gt;();
        deque.offerLast(root);
        while (!deque.isEmpty()) {
            TreeNode node = deque.pollLast();
            result.add(node.val);
            if (node.right != null) {
                deque.offerLast(node.right);
            }
            if (node.left != null) {
                deque.offerLast(node.left);
            }
        }
        return result;
    }

    /*
    // recursive solution
    public List&lt;Integer&gt; preorderTraversal(TreeNode root) {
        List&lt;Integer&gt; result = new ArrayList&lt;&gt;();
        preorderTraversal(root, result);
        return result;
    }

    void preorderTraversal(TreeNode root, List&lt;Integer&gt; result) {
        if (root != null) {
            result.add(root.val);
            if (root.left != null) {
                preorderTraversal(root.left, result);
            }
            if (root.right != null) {
                preorderTraversal(root.right, result);
            }
        }
    }
    */

    @Test
    void test1() {
        assertEquals("[1, 2, 3]", preorderTraversal(newTreeNode(1, null, 2, 3)).toString());
    }

    @Test
    void test2() {
        assertEquals("[]", preorderTraversal(newTreeNode()).toString());
    }

    @Test
    void test3() {
        assertEquals("[1]", preorderTraversal(newTreeNode(1)).toString());
    }

    @Test
    void test52() {
        assertEquals("[1, 4, 2, 3]", preorderTraversal(newTreeNode(1, 4, 3, 2)).toString());
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_145_binary_tree_postorder_traversal"><a class="anchor" href="#_145_binary_tree_postorder_traversal"></a>145. Binary Tree Postorder Traversal</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">package leetcode.problems.p01;

import leetcode.bean.TreeNode;
import org.junit.jupiter.api.Test;

import java.util.*;

import static leetcode.bean.TreeNode.newTreeNode;
import static org.junit.jupiter.api.Assertions.assertEquals;

/**
 * 145. Binary Tree Postorder Traversal
 *
 * @link https://leetcode.com/problems/binary-tree-postorder-traversal/
 * @author zhanglei
 * @date 2022/3/10
 */
class P0145 {
    public List&lt;Integer&gt; postorderTraversal(TreeNode root) {
        List&lt;Integer&gt; result = new ArrayList&lt;&gt;();
        if (root == null) {
            return result;
        }
        Deque&lt;TreeNode&gt; deque = new LinkedList&lt;&gt;();
        deque.offerLast(root);
        while (!deque.isEmpty()) {
            TreeNode node = deque.pollLast();
            result.add(node.val);
            if (node.left != null) {
                deque.offerLast(node.left);
            }
            if (node.right != null) {
                deque.offerLast(node.right);
            }
        }
        Collections.reverse(result);
        return result;
    }

    @Test
    void test1() {
        assertEquals("[3, 2, 1]", postorderTraversal(newTreeNode(1, null, 2, 3)).toString());
    }

    @Test
    void test2() {
        assertEquals("[]", postorderTraversal(newTreeNode()).toString());
    }

    @Test
    void test3() {
        assertEquals("[1]", postorderTraversal(newTreeNode(1)).toString());
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_94_binary_tree_inorder_traversal"><a class="anchor" href="#_94_binary_tree_inorder_traversal"></a>94. Binary Tree Inorder Traversal</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">package leetcode.problems.p00;

import leetcode.bean.TreeNode;
import org.junit.jupiter.api.Test;

import java.util.ArrayList;
import java.util.Deque;
import java.util.LinkedList;
import java.util.List;

import static leetcode.bean.TreeNode.newTreeNode;
import static org.junit.jupiter.api.Assertions.assertEquals;

/**
 * 94. Binary Tree Inorder Traversal
 *
 * @link https://leetcode.com/problems/binary-tree-inorder-traversal/
 * @author zhanglei
 * @date 2022/3/10
 */
class P0094 {
    public List&lt;Integer&gt; inorderTraversal(TreeNode root) {
        List&lt;Integer&gt; result = new ArrayList&lt;&gt;();
        if (root == null) {
            return result;
        }
        Deque deque = new LinkedList();
        deque.offerLast(root);
        while (!deque.isEmpty()) {
            Object obj = deque.pollLast();
            if (obj instanceof TreeNode) {
                TreeNode node = (TreeNode) obj;
                if (node.right != null) {
                    deque.offerLast(node.right);
                }
                deque.offerLast(node.val);
                if (node.left != null) {
                    deque.offerLast(node.left);
                }
            } else {
                result.add((Integer) obj);
            }
        }
        return result;
    }

    @Test
    void test1() {
        assertEquals("[1, 3, 2]", inorderTraversal(newTreeNode(1, null, 2, 3)).toString());
    }

    @Test
    void test2() {
        assertEquals("[]", inorderTraversal(newTreeNode()).toString());
    }

    @Test
    void test3() {
        assertEquals("[1]", inorderTraversal(newTreeNode(1)).toString());
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_102_binary_tree_level_order_traversal"><a class="anchor" href="#_102_binary_tree_level_order_traversal"></a>102. Binary Tree Level Order Traversal</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">package leetcode.problems.p01;

import leetcode.bean.TreeNode;
import org.junit.jupiter.api.Test;

import java.util.ArrayList;
import java.util.Deque;
import java.util.LinkedList;
import java.util.List;

import static leetcode.bean.TreeNode.newTreeNode;
import static org.junit.jupiter.api.Assertions.assertEquals;

/**
 * 102. Binary Tree Level Order Traversal
 *
 * @link https://leetcode.com/problems/binary-tree-level-order-traversal/
 * @author zhanglei
 * @date 2022/3/10
 */
class P0102 {

    public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) {
        List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;();
        if (root == null) {
            return result;
        }
        Deque&lt;TreeNode&gt; deque = new LinkedList&lt;&gt;();
        deque.offer(root);
        while (!deque.isEmpty()) {
            List&lt;Integer&gt; currentLevel = new ArrayList&lt;&gt;();
            for (int i = 0, j = deque.size(); i &lt; j; i++) {
                TreeNode node = deque.poll();
                currentLevel.add(node.val);
                if (node.left != null) {
                    deque.offer(node.left);
                }
                if (node.right != null) {
                    deque.offer(node.right);
                }
            }
            result.add(currentLevel);
        }
        return result;
    }

    /*
    public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) {
        List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;();
        if (root == null) {
            return result;
        }
        Deque&lt;TreeNode&gt; deque = new LinkedList&lt;&gt;();
        deque.offer(root);
        List&lt;Integer&gt; currentLevel = new ArrayList&lt;&gt;();
        int i = 0;
        int currentLevelNum = 1;
        int nextLevelNum = 0;
        while (!deque.isEmpty()) {
            TreeNode node = deque.poll();
            i++;
            currentLevel.add(node.val);
            if (node.left != null) {
                deque.offer(node.left);
                nextLevelNum++;
            }
            if (node.right != null) {
                deque.offer(node.right);
                nextLevelNum++;
            }
            if (i == currentLevelNum) {
                i = 0;
                currentLevelNum = nextLevelNum;
                nextLevelNum = 0;
                result.add(currentLevel);
                currentLevel = new ArrayList&lt;&gt;();
            }
        }
        return result;
    }
    */

    @Test
    void test1() {
        assertEquals(
                "[[3], [9, 20], [15, 7]]",
                levelOrder(newTreeNode(3, 9, 20, null, null, 15, 7)).toString());
    }

    @Test
    void test2() {
        assertEquals("[[1]]", levelOrder(newTreeNode(1)).toString());
    }

    @Test
    void test3() {
        assertEquals("[]", levelOrder(newTreeNode()).toString());
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_107_binary_tree_level_order_traversal_ii"><a class="anchor" href="#_107_binary_tree_level_order_traversal_ii"></a>107. Binary Tree Level Order Traversal II</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">package leetcode.problems.p01;

import leetcode.bean.TreeNode;
import org.junit.jupiter.api.Test;

import java.util.*;

import static leetcode.bean.TreeNode.newTreeNode;
import static org.junit.jupiter.api.Assertions.assertEquals;

/**
 * 107. Binary Tree Level Order Traversal II
 *
 * @link https://leetcode.com/problems/binary-tree-level-order-traversal-ii/
 * @author zhanglei
 * @date 2022/3/10
 */
class P0107 {

    public List&lt;List&lt;Integer&gt;&gt; levelOrderBottom(TreeNode root) {
        List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;();
        if (root == null) {
            return result;
        }
        Deque&lt;TreeNode&gt; deque = new LinkedList&lt;&gt;();
        deque.offer(root);
        while (!deque.isEmpty()) {
            List&lt;Integer&gt; currentLevel = new ArrayList&lt;&gt;();
            for (int i = 0, j = deque.size(); i &lt; j; i++) {
                TreeNode node = deque.poll();
                currentLevel.add(node.val);
                if (node.left != null) {
                    deque.offer(node.left);
                }
                if (node.right != null) {
                    deque.offer(node.right);
                }
            }
            result.add(currentLevel);
        }
        Collections.reverse(result);
        return result;
    }

    @Test
    void test1() {
        assertEquals(
                "[[15, 7], [9, 20], [3]]",
                levelOrderBottom(newTreeNode(3, 9, 20, null, null, 15, 7)).toString());
    }

    @Test
    void test2() {
        assertEquals("[[1]]", levelOrderBottom(newTreeNode(1)).toString());
    }

    @Test
    void test3() {
        assertEquals("[]", levelOrderBottom(newTreeNode()).toString());
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_199_binary_tree_right_side_view"><a class="anchor" href="#_199_binary_tree_right_side_view"></a>199. Binary Tree Right Side View</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">package leetcode.problems.p01;

import leetcode.bean.TreeNode;
import org.junit.jupiter.api.Test;

import java.util.ArrayList;
import java.util.Deque;
import java.util.LinkedList;
import java.util.List;

import static leetcode.bean.TreeNode.newTreeNode;
import static org.junit.jupiter.api.Assertions.assertEquals;

/**
 * 199. Binary Tree Right Side View
 *
 * @link https://leetcode.com/problems/binary-tree-right-side-view/
 * @author zhanglei
 * @date 2022/3/10
 */
class P0199 {
    public List&lt;Integer&gt; rightSideView(TreeNode root) {
        List&lt;Integer&gt; result = new ArrayList&lt;&gt;();
        if (root == null) {
            return result;
        }
        Deque&lt;TreeNode&gt; deque = new LinkedList&lt;&gt;();
        deque.offer(root);
        while (!deque.isEmpty()) {
            for (int i = 0, j = deque.size(); i &lt; j; i++) {
                TreeNode node = deque.poll();
                if (i + 1 == j) {
                    result.add(node.val);
                }
                if (node.left != null) {
                    deque.offer(node.left);
                }
                if (node.right != null) {
                    deque.offer(node.right);
                }
            }
        }
        return result;
    }

    @Test
    void test1() {
        assertEquals("[1, 3, 4]", rightSideView(newTreeNode(1, 2, 3, null, 5, null, 4)).toString());
    }

    @Test
    void test2() {
        assertEquals("[1, 3]", rightSideView(newTreeNode(1, null, 3)).toString());
    }

    @Test
    void test3() {
        assertEquals("[]", rightSideView(newTreeNode()).toString());
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_637_average_of_levels_in_binary_tree"><a class="anchor" href="#_637_average_of_levels_in_binary_tree"></a>637. Average of Levels in Binary Tree</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">package leetcode.problems.p06;

import leetcode.bean.TreeNode;
import org.junit.jupiter.api.Test;

import java.util.ArrayList;
import java.util.Deque;
import java.util.LinkedList;
import java.util.List;

import static leetcode.bean.TreeNode.newTreeNode;
import static org.junit.jupiter.api.Assertions.assertEquals;

/**
 * 637. Average of Levels in Binary Tree
 *
 * @link https://leetcode.com/problems/average-of-levels-in-binary-tree/
 * @author zhanglei
 * @date 2022/3/10
 */
class P0637 {
    public List&lt;Double&gt; averageOfLevels(TreeNode root) {
        List&lt;Double&gt; result = new ArrayList&lt;&gt;();
        if (root == null) {
            return result;
        }
        Deque&lt;TreeNode&gt; deque = new LinkedList&lt;&gt;();
        deque.offer(root);
        while (!deque.isEmpty()) {
            double sum = 0;
            int num = deque.size();
            for (int i = 0; i &lt; num; i++) {
                TreeNode node = deque.poll();
                sum += node.val;
                if (node.left != null) {
                    deque.offer(node.left);
                }
                if (node.right != null) {
                    deque.offer(node.right);
                }
            }
            result.add(sum / num);
        }
        return result;
    }

    @Test
    void test1() {
        assertEquals(
                "[3.00000, 14.50000, 11.00000]".replace("0000", ""),
                averageOfLevels(newTreeNode(3, 9, 20, null, null, 15, 7)).toString());
    }

    @Test
    void test2() {
        assertEquals(
                "[3.00000, 14.50000, 11.00000]".replace("0000", ""),
                averageOfLevels(newTreeNode(3, 9, 20, 15, 7)).toString());
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_429_n_ary_tree_level_order_traversal"><a class="anchor" href="#_429_n_ary_tree_level_order_traversal"></a>429. N-ary Tree Level Order Traversal</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">package leetcode.problems.p04;

import leetcode.bean.Node;
import org.junit.jupiter.api.Test;

import java.util.ArrayList;
import java.util.Deque;
import java.util.LinkedList;
import java.util.List;

import static leetcode.bean.Node.newNode;
import static org.junit.jupiter.api.Assertions.assertEquals;

/**
 * 429. N-ary Tree Level Order Traversal
 *
 * @link https://leetcode.com/problems/n-ary-tree-level-order-traversal/
 * @author zhanglei
 * @date 2022/3/10
 */
class P0429 {
    public List&lt;List&lt;Integer&gt;&gt; levelOrder(Node root) {
        List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;();
        if (root == null) {
            return result;
        }
        Deque&lt;Node&gt; deque = new LinkedList&lt;&gt;();
        deque.offer(root);
        while (!deque.isEmpty()) {
            List&lt;Integer&gt; currentLevel = new ArrayList&lt;&gt;();
            for (int i = 0, j = deque.size(); i &lt; j; i++) {
                Node node = deque.poll();
                currentLevel.add(node.val);
                if (node.children != null) {
                    for (Node child : node.children) {
                        deque.offer(child);
                    }
                }
            }
            result.add(currentLevel);
        }
        return result;
    }

    @Test
    void test1() {
        assertEquals(
                "[[1], [3, 2, 4], [5, 6]]",
                levelOrder(newNode(1, null, 3, 2, 4, null, 5, 6)).toString());
    }

    @Test
    void test2() {
        assertEquals(
                "[[1],[2,3,4,5],[6,7,8,9,10],[11,12,13],[14]]".replace(",", ", "),
                levelOrder(
                                newNode(
                                        1, null, 2, 3, 4, 5, null, null, 6, 7, null, 8, null, 9, 10,
                                        null, null, 11, null, 12, null, 13, null, null, 14))
                        .toString());
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_515_find_largest_value_in_each_tree_row"><a class="anchor" href="#_515_find_largest_value_in_each_tree_row"></a>515. Find Largest Value in Each Tree Row</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">package leetcode.problems.p05;

import leetcode.bean.TreeNode;
import org.junit.jupiter.api.Test;

import java.util.ArrayList;
import java.util.Deque;
import java.util.LinkedList;
import java.util.List;

import static leetcode.bean.TreeNode.newTreeNode;
import static org.junit.jupiter.api.Assertions.assertEquals;

/**
 * 515. Find Largest Value in Each Tree Row
 *
 * @link https://leetcode.com/problems/find-largest-value-in-each-tree-row/
 * @author zhanglei
 * @date 2022/3/10
 */
class P0515 {
    public List&lt;Integer&gt; largestValues(TreeNode root) {
        List&lt;Integer&gt; result = new ArrayList&lt;&gt;();
        if (root == null) {
            return result;
        }
        Deque&lt;TreeNode&gt; deque = new LinkedList&lt;&gt;();
        deque.offer(root);
        while (!deque.isEmpty()) {
            int max = Integer.MIN_VALUE;
            for (int i = 0, j = deque.size(); i &lt; j; i++) {
                TreeNode node = deque.poll();
                if (node.val &gt; max) {
                    max = node.val;
                }
                if (node.left != null) {
                    deque.offer(node.left);
                }
                if (node.right != null) {
                    deque.offer(node.right);
                }
            }
            result.add(max);
        }
        return result;
    }

    @Test
    void test1() {
        assertEquals("[1, 3, 9]", largestValues(newTreeNode(1, 3, 2, 5, 3, null, 9)).toString());
    }

    @Test
    void test2() {
        assertEquals("[1, 3]", largestValues(newTreeNode(1, 2, 3)).toString());
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_116_populating_next_right_pointers_in_each_node"><a class="anchor" href="#_116_populating_next_right_pointers_in_each_node"></a>116. Populating Next Right Pointers in Each Node</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">package leetcode.problems.p01;

import org.junit.jupiter.api.Test;

import java.util.ArrayList;
import java.util.Deque;
import java.util.LinkedList;
import java.util.List;
import java.util.stream.Collectors;

import static leetcode.problems.p01.P0116.Node.newNode;
import static leetcode.problems.p01.P0116.Node.print;
import static org.junit.jupiter.api.Assertions.assertEquals;

/**
 * 116. Populating Next Right Pointers in Each Node
 *
 * @link https://leetcode.com/problems/populating-next-right-pointers-in-each-node/
 * @author zhanglei
 * @date 2022/3/10
 */
class P0116 {
    public Node connect(Node root) {
        if (root == null) {
            return root;
        }
        Deque&lt;Node&gt; deque = new LinkedList&lt;&gt;();
        deque.offer(root);
        while (!deque.isEmpty()) {
            for (int i = 0, j = deque.size(); i &lt; j; i++) {
                Node node = deque.poll();
                if (i + 1 != j) {
                    node.next = deque.peek();
                }
                if (node.left != null) {
                    deque.offer(node.left);
                }
                if (node.right != null) {
                    deque.offer(node.right);
                }
            }
        }
        return root;
    }

    // Definition for a Node.
    public static class Node {
        public int val;
        public Node left;
        public Node right;
        public Node next;

        public Node() {}

        public Node(int _val) {
            val = _val;
        }

        public Node(int _val, Node _left, Node _right, Node _next) {
            val = _val;
            left = _left;
            right = _right;
            next = _next;
        }

        public static Node newNode(Integer... vals) {
            if (vals == null || vals.length == 0) {
                return null;
            }
            Node root = new Node(vals[0]);
            Deque&lt;Node&gt; deque = new LinkedList&lt;&gt;();
            deque.offer(root);
            int i = 1;
            while (i &lt; vals.length &amp;&amp; !deque.isEmpty()) {
                Node node = deque.poll();
                if (vals[i] != null) {
                    deque.offer(node.left = new Node(vals[i]));
                }
                if (vals[i + 1] != null) {
                    deque.offer(node.right = new Node(vals[i + 1]));
                }
                i += 2;
            }
            return root;
        }

        public static String print(Node node) {
            if (node == null) {
                return "[]";
            }
            List&lt;String&gt; result = new ArrayList&lt;&gt;();
            while (node != null) {
                result.add(String.valueOf(node.val));
                Node next = node.next;
                while (next != null) {
                    result.add(String.valueOf(next.val));
                    next = next.next;
                }
                result.add("#");
                node = node.left;
            }
            return result.stream().collect(Collectors.joining(",", "[", "]"));
        }
    }

    @Test
    void test1() {
        assertEquals("[1,#,2,3,#,4,5,6,7,#]", print(connect(newNode(1, 2, 3, 4, 5, 6, 7))));
    }

    @Test
    void test2() {
        assertEquals("[]", print(connect(newNode())));
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_117_populating_next_right_pointers_in_each_node_ii"><a class="anchor" href="#_117_populating_next_right_pointers_in_each_node_ii"></a>117. Populating Next Right Pointers in Each Node II</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">package leetcode.problems.p01;

import leetcode.problems.p01.P0116.Node;
import org.junit.jupiter.api.Test;

import java.util.Deque;
import java.util.LinkedList;

import static leetcode.problems.p01.P0116.Node.newNode;
import static leetcode.problems.p01.P0116.Node.print;
import static org.junit.jupiter.api.Assertions.assertEquals;

/**
 * 117. Populating Next Right Pointers in Each Node II
 *
 * @link https://leetcode.com/problems/populating-next-right-pointers-in-each-node-ii/
 * @author zhanglei
 * @date 2022/3/10
 */
class P0117 {
    public Node connect(Node root) {
        if (root == null) {
            return root;
        }
        Deque&lt;Node&gt; deque = new LinkedList&lt;&gt;();
        deque.offer(root);
        while (!deque.isEmpty()) {
            for (int i = 0, j = deque.size(); i &lt; j; i++) {
                Node node = deque.poll();
                if (i + 1 != j) {
                    node.next = deque.peek();
                }
                if (node.left != null) {
                    deque.offer(node.left);
                }
                if (node.right != null) {
                    deque.offer(node.right);
                }
            }
        }
        return root;
    }

    @Test
    void test1() {
        assertEquals("[1,#,2,3,#,4,5,7,#]", print(connect(newNode(1, 2, 3, 4, 5, null, 7))));
    }

    @Test
    void test2() {
        assertEquals("[]", print(connect(newNode())));
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_104_maximum_depth_of_binary_tree"><a class="anchor" href="#_104_maximum_depth_of_binary_tree"></a>104. Maximum Depth of Binary Tree</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">package leetcode.problems.p01;

import leetcode.bean.TreeNode;
import org.junit.jupiter.api.Test;

import java.util.Deque;
import java.util.LinkedList;

import static leetcode.bean.TreeNode.newTreeNode;
import static org.junit.jupiter.api.Assertions.assertEquals;

/**
 * 104. Maximum Depth of Binary Tree
 *
 * @link https://leetcode.com/problems/maximum-depth-of-binary-tree/
 * @author zhanglei
 * @date 2022/3/10
 */
class P0104 {
    public int maxDepth(TreeNode root) {
        int depth = 0;
        if (root == null) {
            return depth;
        }
        Deque&lt;TreeNode&gt; deque = new LinkedList&lt;&gt;();
        deque.offer(root);
        while (!deque.isEmpty()) {
            depth++;
            for (int i = 0, j = deque.size(); i &lt; j; i++) {
                TreeNode node = deque.poll();
                if (node.left != null) {
                    deque.offer(node.left);
                }
                if (node.right != null) {
                    deque.offer(node.right);
                }
            }
        }
        return depth;
    }

    @Test
    void test1() {
        assertEquals(3, maxDepth(newTreeNode(3, 9, 20, null, null, 15, 7)));
    }

    @Test
    void test2() {
        assertEquals(2, maxDepth(newTreeNode(1, null, 2)));
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_111_minimum_depth_of_binary_tree"><a class="anchor" href="#_111_minimum_depth_of_binary_tree"></a>111. Minimum Depth of Binary Tree</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">package leetcode.problems.p01;

import leetcode.bean.TreeNode;
import org.junit.jupiter.api.Test;

import java.util.Deque;
import java.util.LinkedList;

import static leetcode.bean.TreeNode.newTreeNode;
import static org.junit.jupiter.api.Assertions.assertEquals;

/**
 * 111. Minimum Depth of Binary Tree
 *
 * @link https://leetcode.com/problems/minimum-depth-of-binary-tree/
 * @author zhanglei
 * @date 2022/3/10
 */
class P0111 {
    public int minDepth(TreeNode root) {
        int depth = 0;
        if (root == null) {
            return depth;
        }
        Deque&lt;TreeNode&gt; deque = new LinkedList&lt;&gt;();
        deque.offer(root);
        while (!deque.isEmpty()) {
            depth++;
            for (int i = 0, j = deque.size(); i &lt; j; i++) {
                TreeNode node = deque.poll();
                if (node.left != null) {
                    deque.offer(node.left);
                }
                if (node.right != null) {
                    deque.offer(node.right);
                }
                if (node.left == null &amp;&amp; node.right == null) {
                    deque.clear();
                    break;
                }
            }
        }
        return depth;
    }

    @Test
    void test1() {
        assertEquals(2, minDepth(newTreeNode(3, 9, 20, null, null, 15, 7)));
    }

    @Test
    void test2() {
        assertEquals(5, minDepth(newTreeNode(2, null, 3, null, 4, null, 5, null, 6)));
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_review"><a class="anchor" href="#_review"></a>Review</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_how_alpakka_uses_flow_control_optimizations_in_apache_kafka_2_4"><a class="anchor" href="#_how_alpakka_uses_flow_control_optimizations_in_apache_kafka_2_4"></a><a href="https://www.lightbend.com/blog/alpakka-kafka-flow-control-optimizations">How Alpakka Uses Flow Control Optimizations In Apache Kafka 2.4</a></h3>
<div class="paragraph">
<p>What is Back-pressure?
<span class="image"><img src="_images/back-pressure-demo.gif" alt="back pressure demo"></span></p>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>It works like this: when a downstream stage has room in its buffer it will create a demand request and send it to its immediate upstream stage (pull). The request includes the number of records to push to the downstream stage so that its buffer is full of messages to process. This allows us to only push the exact number of records a downstream stage can handle, and no more. By not sending a demand (pull) request for each record, we get an economy of scales by requiring less signalling overhead per record.</p>
</div>
<div class="paragraph">
<p>This property of the Reactive Streams specification is known as back-pressure. Back-pressure is the key to keeping our asynchronous processing fully utilized while ensuring that it’s not overloaded. Akka Streams implements all the coordination required to enable back-pressure so that the user doesn’t need to be concerned with it.</p>
</div>
</blockquote>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_tip"><a class="anchor" href="#_tip"></a>Tip</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_how_to_commit_case_sensitive_only_changes_in_git"><a class="anchor" href="#_how_to_commit_case_sensitive_only_changes_in_git"></a>How to commit case-sensitive only changes in Git</h3>
<div class="paragraph">
<p>For file, i.e., rename <code>name.txt</code> to <code>NAME.TXT</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre>git mv --cached name.txt NAME.TXT</pre>
</div>
</div>
<div class="paragraph">
<p>For directory, i.e., rename <code>foo</code> to <code>FOO</code>, you&#8217;ll do a two stage rename with a temp name.</p>
</div>
<div class="listingblock">
<div class="content">
<pre>git mv foo foo2
git mv foo2 FOO</pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_share"><a class="anchor" href="#_share"></a>Share</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_grokking_simplicity_taming_complex_software_with_functional_thinking"><a class="anchor" href="#_grokking_simplicity_taming_complex_software_with_functional_thinking"></a>Grokking simplicity: taming complex software with functional thinking</h3>
<div class="sect3">
<h4 id="_chapter_10_first_class_functions_part_1"><a class="anchor" href="#_chapter_10_first_class_functions_part_1"></a>Chapter 10. First-class functions: Part 1</h4>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>First-class means you can store it in a variable, pass it as an argument, and return it from functions.</p>
</div>
</blockquote>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>Higher order means the function takes another function as an argument (or that return a function). You can’t have higher order functions without first-class functions.</p>
</div>
</blockquote>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>forEach() takes an array and a function as arguments. Because it takes a function as an argument, it is a higher-order function.</p>
</div>
</blockquote>
</div>
</div>
</div>
</div>
</div>
</article>
<aside class="toc sidebar" data-title="Contents" data-levels="2">
  <div class="toc-menu"></div>
</aside>
  </div>
</main>
</div>
    <div class="footer-tools">
        <a href="#top" title="Reach the top of the page">Back to top</a>
    </div>
<script src="../../../_/js/vendor/algoliasearch-77ad57d83c.js"></script>
<script src="../../../_/js/site-ca1c0b0367.js"></script>
<script async src="../../../_/js/vendor/highlight-0a351063af.js"></script>
<script async src="../../../_/js/vendor/svg4everybody-195d47ce7d.js"></script>
              </body>
</html>
